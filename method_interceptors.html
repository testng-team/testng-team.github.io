<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<title>Method Interceptors</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel2">
<li><a href="#_method_interceptors">Method Interceptors</a></li>
<li><a href="#_interceptors_for_data_providers">Interceptors for Data Providers</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect2">
<h3 id="_method_interceptors">Method Interceptors</h3>
<div class="paragraph">
<p>Once TestNG has calculated in what order the test methods will be invoked, these methods are split in two groups:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Methods run sequentially</strong>. These are all the test methods that have dependencies or dependents. These methods will be run in a specific order.</p>
</li>
<li>
<p><strong>Methods run in no particular order</strong>. These are all the methods that don&#8217;t belong in the first category. The order in which these test methods are run is random and can vary from one run to the next (although by default, TestNG will try to group test methods by class).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to give you more control on the methods that belong to the second category, TestNG provides {javadocs-base-url}/org/testng/IMethodInterceptor.html[org.testng.IMethodInterceptor]</p>
</div>
<div class="paragraph">
<p>The list of methods passed in parameters are all the methods that can be run in any order. Your intercept method is expected to return a similar list of <code>IMethodInstance</code>, which can be either of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The same list you received in parameter but in a different order.</p>
</li>
<li>
<p>A smaller list of <code>IMethodInstance</code> objects.</p>
</li>
<li>
<p>A bigger list of <code>IMethodInstance</code> objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once you have defined your interceptor, you pass it to TestNG as a listener. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="bash">java -classpath "testng-jdk15.jar:test/build" org.testng.TestNG -listener test.methodinterceptors.NullMethodInterceptor
   -testclass test.methodinterceptors.FooTest</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the equivalent ant syntax, see the listeners attribute in the <a href="https://testng.org/doc/ant.html">ant documentation</a>.</p>
</div>
<div class="paragraph">
<p>For example, here is a Method Interceptor that will reorder the methods so that test methods that belong to the group "fast" are always run first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public List&lt;IMethodInstance&gt; intercept(List&lt;IMethodInstance&gt; methods, ITestContext context) {
  List&lt;IMethodInstance&gt; result = new ArrayList&lt;IMethodInstance&gt;();
  for (IMethodInstance m : methods) {
    Test test = m.getMethod().getConstructorOrMethod().getAnnotation(Test.class);
    Set&lt;String&gt; groups = new HashSet&lt;String&gt;();
    for (String group : test.groups()) {
      groups.add(group);
    }
    if (groups.contains("fast")) {
      result.add(0, m);
    }
    else {
      result.add(m);
    }
  }
  return result;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interceptors_for_data_providers">Interceptors for Data Providers</h3>
<div class="paragraph">
<p>Once TestNG has invoked your data provider, it basically has the data set that is required to be fed via multiple iterations to a <code>@Test</code> annotated test method.</p>
</div>
<div class="paragraph">
<p>But there can be situations wherein you may want to modify the data set before the data set is fed to the test method.</p>
</div>
<div class="paragraph">
<p>This is where the data provider aware interceptors come into picture.</p>
</div>
<div class="paragraph">
<p>TestNG provides a listener named {javadocs-base-url}/org/testng/IDataProviderInterceptor.html[IDataProviderInterceptor] which lets you do this.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a sample implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import org.testng.IDataProviderInterceptor;
import org.testng.IDataProviderMethod;
import org.testng.ITestContext;
import org.testng.ITestNGMethod;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

public class SampleDataInterceptor implements IDataProviderInterceptor {
    @Override
    public Iterator&lt;Object[]&gt; intercept(
            Iterator&lt;Object[]&gt; original, IDataProviderMethod dataProviderMethod,
                                        ITestNGMethod method, ITestContext iTestContext) {
        // The test method would have custom attributes. From them look for a custom attribute
        // whose name is "filter". It's value would the fully qualified class name that
        // can be instantiated using reflection and then used to filter the data provider
        // provided data set.
        Optional&lt;String&gt; found = Arrays.stream(method.getAttributes())
                .filter(it -&gt; "filter".equalsIgnoreCase(it.name()))
                .flatMap(it -&gt; Arrays.stream(it.values()))
                .findFirst();
        if (found.isPresent()) {
            String clazzName = found.get();
            Predicate&lt;Object&gt; predicate = predicate(clazzName);
            Spliterator&lt;Object[]&gt; split = Spliterators.spliteratorUnknownSize(original, Spliterator.ORDERED);
            return StreamSupport.stream(split,false)
                    .filter(predicate)
                    .collect(Collectors.toList())
                    .iterator();
        }
        return original;
    }

    private static Predicate&lt;Object&gt; predicate(String clazzName) {
        try {
            return (Predicate&lt;Object&gt;) Class.forName(clazzName).getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            return input -&gt; true;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s how the filtering capability can look like. This filtering would basically prune through the data set and only allow even numbers to be used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import java.util.function.Predicate;
public class MyFilter implements Predicate&lt;Object&gt; {

    @Override
    public boolean test(Object object) {
        if (object.getClass().isArray()) {
            Object number = ((Object[]) object)[0];
            return (Integer) number % 2 == 0;
        }
        return false;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s how a test case that consumes this listener can look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">import org.testng.annotations.CustomAttribute;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Listeners;
import org.testng.annotations.Test;

@Listeners(SampleDataInterceptor.class)
public class SampleDataDrivenTestCase {

    @Test(dataProvider = "numbers",
            attributes = {
                    @CustomAttribute(name = "filter", values = {"org.testng.demo.MyFilter" })
            }
    )
    public void passingTest(int i) {
        System.err.println("Value = " + i);
    }

    @DataProvider(name = "numbers")
    public Object[][] getNumbers() {
        return new Object[][]{{1}, {2}, {3}, {4}};
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s how the execution output can look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="bash">SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
Value = 2
Value = 4

===============================================
Default Suite
Total tests run: 2, Passes: 2, Failures: 0, Skips: 0
===============================================</code></pre>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-11-17 15:12:10 UTC
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js"></script>
</body>
</html>